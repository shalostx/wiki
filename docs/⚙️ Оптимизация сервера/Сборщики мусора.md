---
sidebar_label: Сборщики мусора
sidebar_position: 3
---

# Сборщики мусора

## Введение

Сборка мусора - это процесс, с помощью которого программы пытаются освободить выделенную память, которая больше не используется объектами. Объект считается «используемым» или «ссылочным», если какая-то часть нашей программы все еще сохраняет на него указатель. И наоборот, к «неиспользуемому» или «нессылаемому» объекту больше не обращается ни одна часть нашей программы, что позволяет освободить занимаемую им память. Сборка мусора является важной частью системы управления памятью Java и по умолчанию управляется виртуальной машиной Java (JVM). В JVM сборщики мусора отвечают за освобождение кучи памяти, в которой хранятся объекты Java. Это помогает обеспечить эффективное использование ресурсов. Кроме того, это избавляет разработчиков от необходимости вручную управлять памятью программы.

Существует множество различных подходов к управлению памятью, и не существует «лучшего» способа сделать это. Даже в одном языке/исполнительной среде может быть несколько подходов к сборке мусора, и JVM - отличный тому пример.

Вместо единственного сборщика мусора современная JVM имеет 5 подходов на выбор:
- Garbage-First (G1) Garbage Collector (по умолчанию, начиная с Java 9)
• Serial Garbage Collector
• Parallel Garbage Collector
• Shenandoah Garbage Collector (Java 12+)
- Z сборщик мусора (доступен для производства с Java 15)

## Z Garbage Collector (ZGC)

Сборщик мусора Z, также известный как ZGC, - это масштабируемый сборщик мусора с низкой задержкой. Впервые он был представлен в Java 11 в качестве экспериментальной функции и стал доступен в Java 15. Его основными задачами являются сверхнизкая задержка и масштабируемость. Это делает его идеальным для веб-приложений или приложений, которые должны обрабатывать большое количество данных, как, например, Minecraft. Он почти полностью параллелен и имеет низкое время паузы - менее 1 мс. Однако по умолчанию он использует негенеративный подход к сборке мусора. Это означает, что он хранит все объекты вместе, независимо от их возраста, поэтому в каждом цикле сборки мусора он собирает все объекты, что требовательно к ресурсам процессора и не рекомендуется для небольших систем.

## Поколенческая сборка мусора

В контексте управления памятью поколение означает категоризацию объектов на основе времени их выделения. Давайте переключим наше внимание на сборку мусора по поколениям. Это стратегия управления памятью, которая работает путем разделения объектов на различные поколения, основанные на времени их выделения, и применения различных подходов в зависимости от их поколения.

В контексте Java память разделена на два основных поколения: молодое и старое. Вновь созданные объекты попадают в молодое поколение, где происходит частая сборка мусора. Объекты, которые сохраняются в течение нескольких циклов сборки мусора, переходят в старшее поколение. Такое разделение оптимизирует эффективность, признавая короткий срок жизни большинства объектов.

Garbage-First Garbage Collector (G1GC) - это сборщик мусора поколения, и до недавнего времени он был единственным сборщиком мусора в JVM. Именно поэтому он был лучшим выбором для Minecraft на протяжении более десяти лет. Но с выходом Java 21 появилась новая альтернатива.

## Поколенческий Z Garbage Collector (ZGC)

Самые большие изменения в Java 21 коснулись сборщика мусора Z. До появления Java 21 ZGC был только негенеративным сборщиком мусора. Это означало, что он не делил кучу на поколения, поэтому при выполнении сканирования он анализировал всю кучу, что, в свою очередь, требовало гораздо больше ресурсов, чем G1GC. Также возникла проблема, когда приложение могло выделять память быстрее, чем GC успевал освобождать ее от мертвых объектов, что в свою очередь заставляло Java-потоки застревать в ожидании памяти. Это компенсировалось двумя решениями: установкой большего размера кучи (что означало, что приложение тратило больше времени на сборку мусора, что еще больше снижало пропускную способность) и увеличением количества потоков для сборщика мусора, чтобы он работал быстрее (что в свою очередь отнимало потоки у приложения). Ни один из этих вариантов не был идеальным, поэтому в Java 21 была проведена работа, чтобы позволить ZGC использовать генерационную сборку мусора.

## Использование поколенческого ZGC в Minecraft

Как уже говорилось ранее, Generational ZGC был добавлен только в Java 21. Minecraft требует Java 21 начиная с версии 1.20.5, которая вышла 23 апреля 2024 года. Чтобы использовать Generational ZGC в старых версиях Minecraft, вам нужно самостоятельно скачать Java 21 и установить ее в качестве среды выполнения Java по умолчанию для каждого экземпляра клиента Minecraft, на котором вы хотите ее использовать, или, если вы запускаете сервер Minecraft, сделать ее средой выполнения Java, запускаемой в вашем стартовом скрипте. Имейте в виду, что старые версии Minecraft, в частности до 1.17, могут не работать с Java 21.

Включение Generational ZGC очень простое. Просто добавьте -XX:+UseZGC -XX:+ZGenerational к аргументам Java либо в клиенте Minecraft, либо в стартовом скрипте вашего сервера между java и -jar. Если вы используете Java 23 или выше, то XX:+ZGenerational больше не нужен, так как он включен по умолчанию.

## Настройка поколенского ZGC

ZGC был спроектирован таким образом, чтобы быть адаптивным и требовать минимальной ручной настройки. Во время выполнения Java-программы ZGC динамически адаптируется к рабочей нагрузке, изменяя размер поколений, масштабируя количество потоков GC и регулируя пороговые значения tenuring. Из-за этого многие аргументы, используемые для настройки G1GC, например -XX:ConcGCThreads=, либо не работают с ZGC, либо не дают никаких преимуществ. Но все же есть вещи, которые нужно учитывать при его использовании.

### Установка максимального размера кучи

Наиболее важной опцией настройки ZGC является установка максимального размера кучи, по сути, ограничения на объем памяти, который может использовать JVM. Это делается с помощью команды `-Xmx=memoryM`, `где memory` - это объем оперативной памяти, который вы хотите выделить для экземпляра Minecraft, в мегабайтах. Поскольку ZGC является параллельным сборщиком, вы должны выбрать максимальный размер кучи таким образом, чтобы куча могла вместить live-набор вашего приложения и в ней оставалось достаточно свободного места для обслуживания выделений во время работы GC. Это означает, что вы не должны устанавливать максимальный размер кучи на весь объем памяти, доступный в вашей системе.

### Возврат неиспользуемой памяти в ОС

По умолчанию ZGC снимает фиксацию с неиспользуемой памяти, возвращая ее операционной системе. Однако это может быть нежелательно для серверов Minecraft, поскольку может негативно повлиять на задержку потоков Java. Лучше всего установить минимальный размер кучи -Xms в то же значение, что и максимальный размер кучи -Xmx, что фактически отключает эту функцию. Однако некоторые хостинг-провайдеры серверов Minecraft делают это просто невозможным. В этом случае единственным способом добиться подобных результатов является добавление -XX:-ZUncommit в аргументы запуска.

### Дальнейшее уменьшение задержки

Не только отмена фиксации, но и фиксация памяти негативно влияет на задержку потоков Java. Поэтому следует также использовать аргумент -XX:+AlwaysPreTouch, который заставит JVM делать страницы в памяти перед запуском приложения, что может еще больше снизить задержку.

### Поддержка NUMA

ZGC имеет поддержку NUMA, что означает, что он будет стараться направлять выделения из кучи Java в NUMA-локальную память. NUMA расшифровывается как Non-Uniform Memory Access и относится к архитектуре, используемой в многосокетных системах. В системах NUMA память делится на несколько узлов памяти, каждый из которых связан с определенным процессором или сокетом. Каждый процессор имеет более быстрый доступ к своему локальному узлу памяти по сравнению с доступом к удаленным узлам памяти.

По умолчанию в ZGC включена поддержка NUMA, что позволяет ему использовать преимущества архитектур NUMA. При работе на NUMA-машине (например, многосокетной x86-машине) включение поддержки NUMA часто дает заметный прирост производительности. Однако если JVM обнаружит, что она должна использовать память на одном узле NUMA, поддержка NUMA будет отключена. Даже если явное включение поддержки NUMA возможно, оно не даст никаких преимуществ, как могут предположить некоторые.

## String Deduplication

Дедупликация строк - это функция JVM, которая существует уже довольно давно. Она помогает сократить использование кучи памяти Java за счет автоматической дедупликации одинаковых массивов символов, которые являются основой для объектов String. В случае с Minecraft она может немного уменьшить использование кучи памяти. Раньше он работал только с G1GC, но в Java 18 огромная его часть была переписана для поддержки ZGC. Кроме того, ее выгоднее использовать с ZGC, поскольку она выполняет дедупликацию строк одновременно. Чтобы включить эту функцию, просто добавьте -XX:+UseStringDeduplication в аргументы запуска.

## Включение Transparent Huge Pages (THP) на Linux

Большие страницы, или иногда огромные страницы, - это техника, позволяющая снизить нагрузку на кэши TLB процессора. Эти кэши используются для ускорения преобразования виртуальных адресов в адреса физической памяти.

Настройка ZGC на использование больших страниц обычно дает лучшую производительность (с точки зрения пропускной способности, задержки и времени запуска) и не имеет реальных недостатков, за исключением того, что ее немного сложнее настроить. Обратите внимание, что не все Linux-машины, предоставляемые хостинг-провайдерами, позволяют использовать Transparent Huge Pages при использовании ZGC, и в этом случае описанный ниже процесс не даст никаких преимуществ.

Процесс настройки требует, чтобы у вас был полный root-доступ к вашей Linux-машине. Для удобства мы будем использовать Transparent Huge Pages (THP). Первое, что вы должны сделать, это запустить эти команды в терминале:

```bash
echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled
```
```bash
echo advise | sudo tee /sys/kernel/mm/transparent_hugepage/shmem_enabled
```
```bash
echo 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag
```
```bash
echo defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag
```

Теперь давайте разберемся, что каждый из них делает:

`echo madvise | sudo tee /sys/kernel/mm/transparent_hugepage/enabled` включает режим madvice.
`echo advise > /sys/kernel/mm/transparent_hugepage/shmem_enabled` включает shmem huge pages для кучи.
`echo 1 | sudo tee /sys/kernel/mm/transparent_hugepage/khugepaged/defrag` включает дефрагментацию от huge pages.
`echo defer | sudo tee /sys/kernel/mm/transparent_hugepage/defrag` настраивает THP для отсрочки дефрагментации huge pages.

После этого останется только добавить `-XX:+UseTransparentHugePages` в аргументы запуска. Вы также должны убедиться, что значение `-Xms` равно значению `-Xmx`, добавление `-XX:-ZUncommit` не является вариантом.

## Итог

ZGC обладает отличными возможностями «из коробки». Добавление поколений делает его еще более универсальным и отличным вариантом для запуска Minecraft.

Просто запустите игру с Java 21 или выше и добавьте `-XmsmemoryM -XmxmemoryM -XX:+UseZGC -XX:+ZGenerational -XX:+AlwaysPreTouch -XX:+UseStringDeduplication` в аргументы запуска, где memory - количество оперативной памяти в мегабайтах, которое вы хотите выделить, должно быть наиболее оптимальным способом оптимизации сбора мусора.

Если установка `-Xms` невозможна, то добавление `-XX:-ZUncommit` будет следующим лучшим вариантом. Для людей, работающих на Linux-машинах, включение Transparent Huge Pages также может быть полезным.

## Источники

Статья переведена с https://github.com/Obydux/Minecraft-startup-flags

