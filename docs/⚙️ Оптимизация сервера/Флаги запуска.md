---
id: flags
sidebar_label: Флаги запуска
sidebar_position: 2
---

# Рекомендуемые флаги запуска JVM

Флаги запуска Minecraft — это параметры, которые добавляются при запуске сервера Minecraft (обычно в командной строке) для настройки производительности, управления памятью, работы JVM (Java Virtual Machine) и других аспектов работы сервера. Они особенно полезны для администраторов серверов, которые стремятся оптимизировать работу своих серверов для большого количества игроков или специфичных модификаций.

## Aikar's Flags

Разберем самый популярный сет флагов, а именно Aikar's Flags

```java
java -Xms10G -Xmx10G -XX:+UseG1GC -XX:+ParallelRefProcEnabled -XX:MaxGCPauseMillis=200 -XX:+UnlockExperimentalVMOptions -XX:+DisableExplicitGC -XX:+AlwaysPreTouch -XX:G1NewSizePercent=30 -XX:G1MaxNewSizePercent=40 -XX:G1HeapRegionSize=8M -XX:G1ReservePercent=20 -XX:G1HeapWastePercent=5 -XX:G1MixedGCCountTarget=4 -XX:InitiatingHeapOccupancyPercent=15 -XX:G1MixedGCLiveThresholdPercent=90 -XX:G1RSetUpdatingPauseTimePercent=5 -XX:SurvivorRatio=32 -XX:+PerfDisableSharedMem -XX:MaxTenuringThreshold=1 -Dusing.aikars.flags=https://mcflags.emc.gs -Daikars.new.flags=true -jar paper.jar --nogui
```

### Рекомендуемая память
Мы рекомендуем использовать не менее 6-10 Гб, независимо от количества игроков! Если вы не можете позволить себе 10 Гб памяти, выделите столько, сколько сможете, но убедитесь, что вы оставили операционной системе немного памяти. G1GC работает лучше с большим объемом памяти.

Однако больший объем памяти не означает более высокую производительность до определенного момента. В конце концов вы достигнете точки убывающей отдачи. Если вы купите 32 Гбайт оперативной памяти для сервера, вы только зря потратите деньги с минимальной отдачей.

:::danger[осторожно]

Не выделяйте всю доступную память на общем хосте!
При установке значений Xms и Xmx, если ваш хост говорит, что у вас 8 ГБ памяти, не используйте 8 ГБ!

Minecraft (и Java) нуждается в дополнительной памяти, помимо параметра Xmx. Рекомендуется уменьшить Xmx и Xms примерно на 1000-1500 МБ, чтобы избежать нехватки памяти или гибели сервера от OOMKiller. Это также оставляет место для операционной системы, чтобы использовать память.

У вас 8 ГБ памяти? Используйте 6500 МБ для безопасности. Но вы также можете спросить у своего хостера, покроет ли он эти накладные расходы и даст ли вам 9500M вместо этого. Некоторые хостеры так и сделают! Просто спросите.
:::

### Техническое объяснение флагов

1. **-Xms**, совпадающие с **-Xmx** - почему: Вы никогда не должны запускать свой сервер с учетом того, что Xmx может привести к полному отсутствию памяти в системе. Всегда следует ожидать, что ваш сервер будет использовать весь Xmx! Затем вы должны убедиться, что у ОС есть дополнительная память поверх этого Xmx для вещей, не связанных с Minecraft/OS. Поэтому никогда не запускайте Minecraft с параметрами Xmx, которые вы не можете поддерживать, если Java использует их все. Это означает, что если Xms меньше Xmx, то у вас есть неиспользуемая память! Неиспользуемая память - это пустая трата памяти. G1 работает тем лучше, чем больше памяти ему предоставлено. G1 адаптивно выбирает, сколько памяти отдать каждому региону, чтобы оптимизировать время паузы. Если у вас больше памяти, чем нужно для достижения оптимального времени паузы, G1 просто переместит лишнюю память в старое поколение, и это вам не повредит. Основная идея улучшения поведения GC заключается в том, чтобы гарантировать, что недолговечные объекты умрут молодыми и никогда не получат повышения. Чем больше памяти у G1, тем больше гарантий, что объекты не будут преждевременно перемещены в старое поколение. G1 работает иначе, чем предыдущие сборщики, и способен более эффективно обрабатывать большие кучи.
Если ему не нужна предоставленная память, он не будет ее использовать. Весь движок работает по-другому и не страдает от слишком больших куч, и это общепринятая в индустрии информация о том, что в G1 нужно держать Xms и Xmx одинаковыми!

:::warning[Внимание]
Совет установить xmx == xms **ИСПОЛЬЗОВАЛСЯ** потому, что JVM вызывала free() для областей памяти, которые больше не использовались, а затем вскоре после этого возвращала их malloc().
И это происходило в цикле.
Вызовы malloc() могут быть медленными, поэтому общим советом было установить xms == xmx.
Это было **«исправлено»** в течение долгого времени. Возможно, еще до появления Java 11.
:::

2. UnlockExperimentalVMOptions: необходим для некоторых нижеприведенных вариантов.

3. G1NewSizePercent: Это важные параметры. Теперь вы можете указать процент от общего желаемого диапазона для нового поколения. С помощью этих настроек мы скажем G1 не использовать стандартные 5% для нового поколения, а вместо этого дать ему 40%! Minecraft имеет чрезвычайно высокую скорость выделения памяти - не менее 800 МБ/с на сервере с 30 игроками! И это в основном недолговечные объекты (Block Position). Это означает, что Minecraft нужно больше внимания уделять новому гене, чтобы иметь возможность поддерживать такую скорость распределения памяти. Если ваш new gen слишком мал, вы будете запускать сборники new gen 1-2+ раза в секунду, а это ужасно. У вас будет так много пауз, что TPS может пострадать, а сервер не сможет справиться с затратами на GC. Затем добавьте тот факт, что объекты теперь будут продвигаться быстрее, в результате чего ваш старый ген будет расти быстрее. Учитывая большее количество нового гена, мы можем замедлить интервалы между коллекциями молодого гена, в результате чего у недолговечных объектов будет больше времени, чтобы умереть молодыми, и в целом более эффективное поведение GC.

4. G1MixedGCLiveThresholdPercent: Контролирует, когда включать регионы в смешанных GC в коллекцию молодых GC, сохраняя старый ген в порядке, не делая обычную коллекцию старых генов GC. Если ваша память меньше этого процента, старый ген даже не будет включаться в «смешанные» коллекции. Смешанные коллекции не так тяжелы, как полная коллекция old, поэтому небольшие инкрементные очистки old позволяют поддерживать небольшое потребление памяти. По умолчанию от 65 до 85 в зависимости от версии Java, мы устанавливаем значение 90, чтобы обеспечить максимально быстрое удаление мусора в old gen и сохранить как можно больше свободных областей.

5. G1ReservePercent=20: Скорость выделения памяти в Minecraft в последних версиях действительно безумна. Мы рискуем столкнуться с ужасным «исчерпанием пространства», не имея достаточно свободной памяти для перемещения данных. Это гарантирует, что больше памяти будет ожидать использования для этой операции. По умолчанию это значение равно 10, поэтому мы добавим к нему еще 10.

6. MaxTenuringThreshold=1: В Minecraft очень высокая скорость выделения памяти. Большая часть этой памяти восстанавливается при генерации Эдема. Однако переходные данные будут переполнять выжившего. Изначально мы играли с полным удалением survivor и получили неплохие результаты, но в результате переходные данные попадают в old, что не очень хорошо. Max Tenuring 1 гарантирует, что мы не будем продвигать переходные данные в старое поколение, но все, что переживет 2 прохода GC, будет считаться более долгоживущим.

7. SurvivorRatio=32: Поскольку мы резко уменьшили MaxTenuringThreshold, мы резко сократим использование пространства для выживших. Это освободит больше регионов, которые будут использоваться eden.

8. AlwaysPreTouch: AlwaysPreTouch настраивает и резервирует память при запуске процесса, обеспечивая ее смежность, что повышает эффективность работы с ней. Это повышает скорость доступа операционной системы к памяти. Обязательное использование прозрачных огромных страниц

9. +DisableExplicitGC: Многие плагины думают, что знают, как контролировать память, и пытаются вызвать сборку мусора. Плагины, которые так делают, вызывают полную сборку мусора, что приводит к огромному скачку лага. Этот флаг запрещает плагинам пытаться делать это, защищая вас от их плохого кода.

10. MaxGCPauseMillis=200: Этот параметр контролирует, сколько памяти будет использовано между минимальным и максимальным диапазонами, указанными для вашего нового поколения. Это «цель» того, как долго вы хотите, чтобы ваш сервер приостанавливал сбор данных. 200 - это максимум потеря 4 тиков. Это приведет к кратковременному падению TPS, однако сервер сможет восполнить это падение мгновенно, то есть оно не окажет существенного влияния на ваш TPS. 200 мс - это меньше, чем могут распознать игроки. При тестировании это значение было ограничено еще более низким числом, что привело к тому, что G1 недостаточно быстро собирает память, и потенциально старые гены могут закончиться, что приведет к полному сбору. То, что это число равно 200, не означает, что каждая коллекция будет равна 200. Это значит, что он может использовать до 200, если ему это действительно нужно, и мы должны позволить ему делать свою работу, когда есть память для сбора.

11. +ParallelRefProcEnabled: Оптимизирует процесс GC для использования нескольких потоков для проверки слабых ссылок. Не знаю, почему это не сделано по умолчанию...

12. G1RSetUpdatingPauseTimePercent=5: По умолчанию 10% времени, затрачиваемого во время паузы на обновление RSets, уменьшите это значение до 5%, чтобы сделать его более одновременным и сократить длительность паузы.

13. G1MixedGCCountTarget=4: По умолчанию 8. Поскольку мы стремимся собирать медленнее, с меньшим использованием старых генов, старайтесь быстрее освобождать память старых генов, чтобы избежать истощения старых.

14. G1HeapRegionSize=8M+: По умолчанию вычисляется автоматически. Очень важно для Minecraft, особенно для 1.15, так как в ситуациях с малым количеством памяти расчет по умолчанию в большинстве случаев будет слишком мал. Любое выделение памяти, вдвое меньшее этого размера (4 МБ), будет расценено как «Humongous» и сразу перейдет в старое поколение, а освободить его будет сложнее. Если вы позволите Java использовать значение по умолчанию, вы будете уничтожены значительным куском памяти, который будет рассматриваться как «Humongous».

15. +PerfDisableSharedMem: Заставляет GC писать в файловую систему, что может привести к большим задержкам, если дисковое IO велико - см. https://www.evanjones.ca/jvm-mmap-pause.html.


## hilltty's Flags

Почему не флаги Айкара?

Все очень просто, сбор мусора у него основан, как он говорит, на невероятно стабильном, но крайне медленном по текущим меркам алгоритме G1. При этом всем он максимально устарел, все, что он реализовал, было инновационным во времена JDK 8, сейчас - нет. Действительно, зачем менять то, что работает? А стоило бы.

На замену я предлагаю поставить Shenandoah - это сборщик мусора с невероятно малым временем паузы, что так раз подходит для нашей любимой игры, мы же все не любим фризы. На стабильность это никак не повлияло, за все время бесперебойного тестирования не было выявлено ни одной проблемы.

> ### Отказ от ответственности
> Я не призываю всех тут же менять свои свойста запуска сервера, я лишь даю понять, что ничего идеального не бывает. Так же я не отвечаю за стабильность работы моих параметров в вашем конкретном случае, все системы разные, а результаты абсолютно индивидуальны.
>
> @hilltty

### Флаги

**Поддержививаемые сборки JDK:**

*Рекомендую использовать OpenJDK 17*

- [x] OpenJDK 8+
- [x] Red Hat 8+
- [x] Amazon 11+
- [x] Azul 11+
- [x] AdoptOpenJDK 11+
- [ ] Oracle
- [ ] SAP

**Поддержививаемые сервера:**

- [x] Vanilla
- [x] Bukkit, Spigot, Paper...
- [x] Fabric
- [x] Forge

**Готовые свойства:**

```yml
java -jar -server -Xms6G -Xmx6G -XX:+UseLargePages -XX:LargePageSizeInBytes=2M -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -XX:ShenandoahGCMode=iu -XX:+UseNUMA -XX:+AlwaysPreTouch -XX:-UseBiasedLocking -XX:+DisableExplicitGC -Dfile.encoding=UTF-8 launcher-airplane.jar --nogui
```

> Предупреждение `Option UseBiasedLocking was deprecated in version 15.0 and will likely be removed in a future release.` может безопасно игнорироваться и использоваться на вашем сервере, флаг UseBiasedLocking прекрасно выполняет свои функции.

**А теперь внимательно разберем, что за что отвечает:**

*-Xms6G* и *-Xmx6G*: устанавливает границы использования памяти вашим сервером Minecraft, рекомендую не использовать более 12 Гб для вашего сервера и всегда оставлять 1 - 2 Гб свободной памяти для системы.

*-XX:+UseLargePages* и *-XX:LargePageSizeInBytes=2M*: позволяет использовать зарегистрированую память большими страницами, ускоряет скорость запуска и отзывчивость сервера. Заставим Linux регистрировать страницы для нас. Добавляем эту строку в `/etc/sysctl.conf`:

```yml
vm.nr_hugepages = 3372
```

Как мы получили это число? Допустим, я хочу зарегистрировать 6 Гб больших страниц, для этого делю 6 Гб на 2.

```yml
6 * 1024 / 2 = 3072
```

Далее я рекомендую оставить немного свободного места, и добавить 300 к нашему числу.

```yml
3072 + 300 = 3372
```

После перезагружаем систему для применения изменений. Убедиться в том, что память успешно зарегистрована можно командой `grep -i hugepages /proc/meminfo`.

---
*-XX:+UnlockExperimentalVMOptions*: включает возможность использования эксперементальных возможностей.

*-XX:+UseShenandoahGC*: использование в роли алгоритма сборки мусора проект Шенандоа.

*-XX:ShenandoahGCMode=iu*: включение экспериментального режима работы нашего сборщика, он является зеркалом режима SATB, что сделает разметку менее консервативной, особенно в отношении доступа к слабым ссылкам.

---
*-XX:+UseNUMA*: включает чередование NUMA на хостах с несколькими сокетами, в сочетании с AlwaysPreTouch он обеспечивает лучшую производительность, чем стандартная готовая конфигурация. Более подробно о данной архитектуре можно узнать [отсюда](https://en.wikipedia.org/wiki/Non-uniform_memory_access).

*-XX:+AlwaysPreTouch*: предрегистрация сразу всей выделенной памяти, уменьшает заддержки ввода.

*-XX:-UseBiasedLocking*: существует компромисс между пропускной способностью неограниченной (предвзятой) блокировки и безопасными точками, которые JVM делает, чтобы включать и выключать их по мере необходимости. Для рабочих нагрузок, в том числе сервера Minecraft, ориентированных на задержку, имеет смысл отключить предвзятую блокировку.

*-XX:+DisableExplicitGC*: вызов System.gc () из пользовательского кода заставляет ShenandoahGC выполнить дополнительный цикл сборки мусора, отключение защищает от кода злоупотребляющего этим.

### Система

Tuned-adm - это инструмент командной строки, который позволяет переключаться между настроенными профилями для повышения производительности в ряде конкретных случаев использования. Установите пакет с помощью `apt-get`:

```yml
sudo apt-get install tuned
```

Далее вам нужно подобрать конфиг под вашу систему, я рекомендую использовать `throughput-performance` или `latency-performance`, установите нужный вам профиль:

```yml
sudo tuned-adm profile throughput-performance
```

Убедиться в том, что изменения применены можно командой `tuned-adm profile`.

Подробная статья о всех профилях и в каких случаях их стоит использовать [здесь](https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/performance_tuning_guide/sect-red_hat_enterprise_linux-performance_tuning_guide-tool_reference-tuned_adm).

### Дополнительная конфигурация

#### bukkit.yml

```yml
chunk-gc:
 period-in-ticks: 600
```

**Рекомендованное значение `chunk-gc.period-in-ticks`:**

Не выделяйте больше чем 12 Гб памяти, это не даст никакого эффекта в большинстве случаев.

| Память / Кол-во игроков | до 30 | 30 - 60 | 60 - 100 | более 100 |
| :--- | :---: | :---: | :---: | :---: |
| 4 Гб | 400 | - | - | - |
| 8 Гб | 600 | 400 | 300 | - |
| 12 Гб | 1200 | 800 | 600 | 400 |

## Послесловие

На самом деле ничего из вышеперечисленных вариантов зарекомендовать не могу. Лучшей рекомендацией будет попробовать каждый из вариантов и понять, что для вас лучше. Самим лучшим советом будет сделать свой сет флагов и выбрать оптимальный сборщик мусора для вас.

:::tip[Подсказка]

Для быстрой генерации флагов можете пользоваться сервисом [Birdflop](https://www.birdflop.com/resources/flags/)